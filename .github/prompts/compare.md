If no specific projects are provided as options, default to analyzing all projects present in the current workspace. Begin by performing a thorough and fully detailed analysis of each project, providing a comprehensive professional review that includes, but is not limited to: project objectives, architecture and design patterns, technologies and dependencies used, code quality (e.g., readability, efficiency, adherence to best practices), documentation completeness, testing coverage, scalability, security measures, performance metrics, potential bugs or vulnerabilities, integration points with other systems, user interface and experience details, licensing and compliance aspects, version control history, and any unique features or innovations. For each project, highlight strengths, weaknesses, and areas for improvement, drawing on industry standards and best practices.

Next, provide a complete and fully detailed comparison of the projects to each other, covering similarities, differences, overlapping functionalities, complementary aspects, conflicting elements, and trade-offs. Use structured metrics such as feature sets, performance benchmarks, maintenance overhead, extensibility, and overall suitability for various use cases to facilitate an objective evaluation.

Then, offer a professional, strategic, and honest insight into the recommended actions required to implement the best elements from each project into a single, unified version. This should include a step-by-step plan with specifics such as: prioritization of features to merge (e.g., retaining superior UI from one and backend logic from another), refactoring strategies to resolve conflicts (e.g., harmonizing authentication methods or database schemas), integration techniques (e.g., using APIs or modular components), timelines for development phases, resource allocation (e.g., tools, team roles), risk assessments and mitigation plans, and validation methods (e.g., testing suites for the merged product). Ensure the insight emphasizes feasibility, cost-effectiveness, and alignment with long-term goals.

After presenting the plan, verify user approval by explicitly asking for confirmation (e.g., "Do you approve this plan to proceed?"). If they do not approve, inquire whether they would like an alternative plan generated or prefer to edit specific parts of the current plan, then iterate accordingly based on their response.

Once the plan is approved, ask if they would like to initiate the creation of the new, improved project version immediately or save the plan as a document for later use. If they choose to start creation, begin building the new project in a new folder within the workspace, inside the user-specified directory, following the approved plan's steps incrementally while providing progress updates. If they choose to save the plan, create a detailed document (e.g., in Markdown or PDF format) containing all reviews, comparisons, insights, and the full plan, saving it in the user-specified directory. In both cases, confirm successful completion and offer further assistance.

summary
Your task is to create a detailed summary of the conversation so far, paying close attention to the user's explicit requests and your previous actions.
This summary should be thorough in capturing technical details, code patterns, and architectural decisions that would be essential for continuing with the conversation and supporting any continuing tasks.

Your summary should be structured as follows:
Context: The context to continue the conversation with. If applicable based on the current task, this should include:

1. Previous Conversation: High level details about what was discussed throughout the entire conversation with the user. This should be written to allow someone to be able to follow the general overarching conversation flow.
2. Current Work: Describe in detail what was being worked on prior to this request to summarize the conversation. Pay special attention to the more recent messages in the conversation.
3. Key Technical Concepts: List all important technical concepts, technologies, coding conventions, and frameworks discussed, which might be relevant for continuing with this work.
4. Relevant Files and Code: If applicable, enumerate specific files and code sections examined, modified, or created for the task continuation. Pay special attention to the most recent messages and changes.
5. Problem Solving: Document problems solved thus far and any ongoing troubleshooting efforts.
6. Pending Tasks and Next Steps: Outline all pending tasks that you have explicitly been asked to work on, as well as list the next steps you will take for all outstanding work, if applicable. Include code snippets where they add clarity. For any next steps, include direct quotes from the most recent conversation showing exactly what task you were working on and where you left off. This should be verbatim to ensure there's no information loss in context between tasks.

Example summary structure:

1. Previous Conversation:
   [Detailed description]
2. Current Work:
   [Detailed description]
3. Key Technical Concepts:

- [Concept 1]
- [Concept 2]
- [...]

4. Relevant Files and Code:

- [File Name 1]
  - [Summary of why this file is important]
  - [Summary of the changes made to this file, if any]
  - [Important Code Snippet]
- [File Name 2]
  - [Important Code Snippet]
- [...]

5. Problem Solving:
   [Detailed description]
6. Pending Tasks and Next Steps:

- [Task 1 details & next steps]
- [Task 2 details & next steps]
- [...]

Output only the summary of the conversation so far, without any additional commentary or explanation.
